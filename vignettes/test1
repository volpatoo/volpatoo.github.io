---
title: "Genotype by Environment analysis using statgenGxE"
author: "Leonardo Volpato"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    keep_md: yes
    toc: false
    number_sections: true
  pdf_document:
    toc: false
    number_sections: true
  html_notebook:
    toc: false
    number_sections: true
fig_caption: yes
link-citations: true
bibliography: GxE paper.bib
classoption: a4paper
csl: crop-science.csl
nocite: '@*' #This will force all items to be displayed in the bibliography

---
 
```{r global_options, include = FALSE}
knitr::opts_chunk$set(comment = "#>", 
                      collapse = TRUE,
                      echo = TRUE,
                    	message = FALSE,
                    	warning = FALSE,
                      fig.dim = c(7, 4)
)
op <- options(width = 90)
options(tinytex.verbose = TRUE)
```

### About this project (paper) {-}

The present analysis aims to dissect the genotype by environment interaction study (aka GEI) using a data set from the Dry Beans breeding program - MSU. 

The trait in the study is the yield per plot (lb/plot) adjusted to the international measurements (Kg/ha). A previous report was done to describe further details in the raw data adjustment analysis. Plant maturity also will be investigated in order to check the MTME model effects.

In this vignette, different types of analysis will be performed in order to study the GEI in the Multi-Environment-Trials (MET) data to provide better varieties recommendations to the breeding program.

The core functions in this vignette are available at [@statgenGxE] and [@metan] R packages. The availability of functions in these packages is based on the analyses described in [@Malosetti2013] and [@Olivoto2019]. Further suggested reading is [@vanEeuwijk2016], [@ColombariFilho].

The following types of analysis will be done using the packages described previously: (this topic list will be edited, but for now we have a reference list)

## **Summary**{-}

1. * [Data preparation](#dp)
   * [Box plot figure using the statGxE R package](#TDboxplot1)
   * [Map of locations](#mapEnv) 
   
2. [BLUP model for MET trials - Working with all the Market Class beans](#allmkt)
   * [Mixed model analysis](#mixmodan)
     * [GEI Unstructure model](#modus)
     * [GEI ASReml model 1](#asremmod1)

      
3. [BLUP model for MET trials - Working with all the Market Class beans](#allmkt)
   * [Mixed model analysis](#mixmodan)
     * [GEI Unstructure model](#modus)
     * [GEI ASReml model 1](#asremmod1)
    * [2-Stage mixed model analysis 1](#2stmodan1)
      * [StatgenGxE model 1 - nestingFactor](#StatgenGxEmod1)
      * [GEI ASReml model 2](#asremmod2)
   
4. [BLUP model for MET trials - Working with all the Market Class beans](#allmkt)
   * [Mixed model analysis](#mixmodan)
     * [GEI Unstructure model](#modus)
     * [GEI ASReml model 1](#asremmod1)
    * [2-Stage mixed model analysis 1](#2stmodan1)
      
      
5. [BLUP model for MET trials - Working with all the Market Class beans](#allmkt)
   * [Mixed model analysis](#mixmodan)
     * [GEI Unstructure model](#modus)
     * [GEI ASReml model 1](#asremmod1)
    * [2-Stage mixed model analysis 1](#2stmodan1)
      * [StatgenGxE model 1 - nestingFactor](#StatgenGxEmod1)
      * [GEI ASReml model 2](#asremmod2)
    

---


### Setting up the working directory {-} 
```{r directory}
rm(list=ls())
my.path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my.path)
# R setup ###########
options("scipen"=999,"digits" =5) # set numbering format
```

### Load and install necessary Packages {-}
```{r loading r packages, echo=FALSE}
if(!require("pacman")) install.packages("pacman")

pacman::p_load(metan,
               asreml,
               asremlPlus,
               DT,  # Used to make the tables
               ggplot2,
               dplyr,
               data.table,
               plyr,
               ggplot2,
               raster,
               tidyr,
               maps,
               mapdata,
               tigris,
               rcartocolor,
               cowplot,
               sf,
               statgenGxE, 
               nadiv,
               broom,
               spData
               
)
```


### Rendering engine{-}
*This vignette some table will be built with [@pkgdown]. All tables will be produced with the package DT using the following function.*
```{r print table function}
library(DT) # Used to make the tables
# Function to make HTML tables
print_table <- function(table, rownames = FALSE, digits = 6, ...){
  df <- datatable(table, rownames = rownames, extensions = 'Buttons',
                  options = list(scrollX = TRUE, 
                                 dom = '<<t>Bp>',
                                 buttons = c('copy', 'excel', 'pdf', 'print')), ...)
  num_cols <- c(as.numeric(which(sapply(table, class) == "numeric")))
  if(length(num_cols) > 0){
    formatSignif(df, columns = num_cols, digits = digits)
  } else{
    df
  }
}
```


# Data preparation {#dp}

The data in `CleanData_final_01` will be used after the clean and quality process.\n
This data set was provided by Scott Bates and it consists of data with genotype, market classes, locations, years, repetitions, yield, and maturity. The data came from 4 different locations: Bay (BA), Tuscola (TU), Sanilac (SA), and Huron (HU). The following table shows the principal data structure from this project, in which BB is Black Beans, NA = Navy Beans, and SR = Small Red.

**For the purpose of this study, the `Loc` effect will be considered as the trial effect (Env). In this case, 4 environments will be considered. This aim is important to define the environment recommendations according to the genotype performance.** 

*General data distribution number for each factor from this analysis*

--------------------------------------------------------
 Mkt class     Genotype   Rep.    Loc     Year          
------------ ----------- ------ ------- -------
     BB           29        4       4        5
     
     NB           35        4       4        5     

     SR           11        4       4        5           
     
     TOTAL        75        3       4        5
---------------------------------------------------------

## Loading data set to factor
The data in `CleanData_final_01` will be used after the clean and quality process has been performed.
*Reading all Market classes together and individually*
```{r loadData 1}
data_beans = read.csv("CleanData_final_01.csv",h=T, stringsAsFactors = T)
data_beans <- data_beans %>%
  unite("rep_loc",c("rep","loc"), remove = F, na.rm = F)
data_beans %>%
  as_tibble()
### Data adjustment
#All the effect columns must be as a factor to run in ASReml-r.\n
#Removing NA's values for the `yield_kg_ha_adj_all` column (trait) in order to avoid any mistake.
cols <- c("rep", "rep_loc", "name", "loc","year", "expt", "year_loc")
data_beans[cols] <- lapply(data_beans[cols], factor)
data_beans <- data.table(data_beans)
data_beans <- na.omit(data_beans,cols = "yield_kg_ha_adj_all") 
#str(data_beans)
```


# Two Stage mixed model analysis {#stmodan2}
## Method - 1: Subset `rep` and `loc` {#stmodanreploc}

We will correct the genetic values by `year` within `loc` and `rep` in order to investigate the residuals values.
The following pepiline will be used: 1-Stage = BLUEs estimation for the vector of the variable yield in the ith genotype, and jth year within `loc` and `rep.` Then the BLUEs from the 1-Stage (Yik) will be used to predict the BLUPs (Yijl) of the ith genotype in the lth location and jth rep in the 2-Stage in which this second model have `name` and `loc` effects as random.

### Loop per location and rep using the asreml R pachage:

The LSMEANS will be estimated using a mixed-effect model. The BLUEs will be obtained by location and rep using a loop with [@asreml] and storage into the list. \n
The following mixed model was used to estimate the BLUEs of each genotype within location and rep with one value per genotype per experiment, for the first step (random effects are underlined in all equations):

$$
{\sf\underline{Y_{ik}} = \mu  + {G_i} + \underline{S_{ik}} +  \underline{\varepsilon_{ik}} }
$$

where $y_{ik}$ is the  observed yield in the *i*th genotype and *k*th year, $\mu$ is the overall mean, $G_i$ is the effect of the *i*th genotype, $S_{k}$ is the effect of the *k*th year, and $\varepsilon_{ik}$ are the residual, with $S_{k}$~N(0,$\sigma_{Y}^{2}$), and $\varepsilon_{ik}$~N(0,$\sigma_{\varepsilon}^{2}$), all independent, where $\sigma_{Y}^{2}$ is the year variance, and $\sigma_{\varepsilon}^{2}$ is the mean error variance across experiments. \n

The BLUEs will be obtained by location and rep (`rep_loc`) using a loop with [@asreml] and storage it into the `stgI_list` list. The output here will be a table with `name`, `yield_LSM`, `se` columns. 

```{r asreml blues 1, message=FALSE, warning=FALSE}
## Analysis per site
Envs <- levels(data_beans$rep_loc)

stgI_list <- matrix(data=list(), nrow=length(Envs), ncol=1,
                    dimnames=list(Envs, c("lsmeans")))

############################
##### Stage I LSMEANS #####

for (i in Envs){
  
  Edat <- droplevels(subset(data_beans, rep_loc==i))
  
  print(i)
  
  mod.1 <- asreml(fixed       = yield_kg_ha_adj_all ~ name ,
                  random      = ~ year ,
                  data        = Edat,
                  #predict     = predict.asreml(classify = "name"),
                  trace       = F,
                  maxit       = 500)
  
  
  print(summary.asreml(mod.1)$varcomp)
  wald(mod.1)
  
  blue<- predict(mod.1, classify="name", levels=levels(Edat$name), vcov=TRUE, aliased = T)
  blue.1 <- data.table(blue$pvals)[, c(1:3)]
  names(blue.1) <- c("name", "yield_LSM", "se")

  stgI_list[[i, "lsmeans" ]] <- blue.1 # put all the results of Stage 1 in the list
  
  rm(Edat,mod.1, blue, blue.1)
  
  
 
}
```


### Preparing dataset of Stage I for Stage II 

Merging the original data to have all the factors in the final table with: `name`, `loc`, `expt`, `rep`, `rep_loc`

```{r Preparing dataset to Stage II a}
##### Unlist the results of Stage I and format as data.table #####
lsm_stageI <- data.table(ldply(stgI_list[, "lsmeans"], data.frame, .id="rep_loc"))
lsm_stageI <- lsm_stageI[order(lsm_stageI$rep_loc,lsm_stageI$name),]

lsm_stageI$units <- seq.int(nrow(lsm_stageI))
#str(lsm_stageI)

data_beans_col <- data_beans[,c("name", "loc",  "expt","rep", "rep_loc")]

data_beans_col <- data_beans_col[order(data_beans_col$rep_loc,data_beans_col$name),]

lsm_stage.I <- merge(data_beans_col, lsm_stageI,
                     by=c("name","rep_loc"))

lsm_stage.I <- droplevels(lsm_stage.I[!duplicated(lsm_stage.I$units),])
str(lsm_stage.I)

#write.csv(lsm_stage.I,"lsm_stage.I.csv",row.names=T,quote=F)
```


### The BLUP model for MET trials

The following linear mixed model with interaction effect will be used in the 2-Stage in order to investigate the multi-environment trials (MET) as follow by [@metan] R package:

$$
{\sf\underline{Y_{ijl}} = \mu  + \underline{G_i}  + E_l + \beta_{jl} + \underline{GE_{il}}  +  \underline{\varepsilon_{ijl}} }
$$
	
where ${y_{ijl}}$ is the response variable (e.g., grain yield) observed in the *j*th repetion of the *i*th genotype in the *l*th location (*i* = 1, 2, ..., *g*;  *j* = 1, 2, ..., *b*; *l* = 1, 2, ..., *e*); $\mu$ is the grand mean; $\underline{G_i}$ is the effect of the *i*th genotype; $E_l$ is the effect of the *l*th location (env); $\beta_{jl}$ is the effect of the *j*th rep with the *l*th location; $\underline{GE_{il}}$ is the interaction effect of the *i*th genotype nested within the *l*th location; and $\mathop \varepsilon \nolimits_{ijl}$ is the random error, in witch with $G_{i}$~N(0,$\sigma_{G}^{2}$), $GE_{il}$~N(0,$\sigma_{GE}^{2}$), and $\varepsilon_{ijl}$~N(0,$\sigma_{\varepsilon}^{2}$), all independent, where $G_{G}^{2}$ is the genotype (name) variance,$GS_{GE}^{2}$ is the interaction genotype x environment variance, and $\sigma_{\varepsilon}^{2}$ is the mean error variance across experiments. \n

### `mod.met.4`
```{r mod met 1}
mod.met.4 <- asreml(fixed       = yield_LSM ~  loc + loc:rep,
                     random      = ~  name + name:loc,
                     data        = lsm_stage.I,
                     predict     = predict.asreml(classify = "name"),
                     trace       = F,
                     maxit       = 500)


print(wald(mod.met.4))
print(summary.asreml(mod.met.4)$varcomp)
print(summary.asreml(mod.met.4)$bic)
blup.met.4<- data.table((mod.met.4$predictions$pvals[1:3]))
names(blup.met.4) <- c("name", "yield_LSM_MET", "se")

```

### `mod.met.metan.a` Metan MET analysis
```{r mod metan 1}
 mixed_mod.a <- 
   gamem_met(lsm_stage.I,
             env = loc,
             gen = name,
             rep = rep,
             resp = yield_LSM,
             random = "gen", #Default
             verbose = TRUE) #Default
 
 blup.metan.a<- mixed_mod.a$yield_LSM$BLUPgen
 blup.metan.int.a<- mixed_mod.a$yield_LSM$BLUPint
 blup.metan.means.a<- means_by(blup.metan.int.a,GEN,ENV)


```


## Method - 2: Subset `loc` {#stmodanloc}

We will correct the genetic values by `year` within `loc` in order to investigate the residuals values.
The following pepiline will be used: 1-Stage = BLUEs estimation for the vector of the variable yield in the ith genotype and jth block, and jth year within `loc`. Then the BLUEs from the 1-Stage (Yik) will be used to predict the BLUPs (Yijl) of the ith genotype in the lth location and jth rep in the 2-Stage in which this second model have `name` and `loc` effects as random.

### Loop per location and rep using the asreml R pachage:

The LSMEANS will be estimated using a mixed-effect model. The BLUEs will be obtained by location and rep using a loop with [@asreml] and storage into the list. \n

The following mixed model was used to estimate the BLUEs of each genotype within location and rep with one value per genotype per experiment, for the first step (random effects are underlined in all equations):

$$
{\sf\underline{Y_{ijk}} = \mu  + {G_i}  + \underline{S}_k + \beta_{jk} + \underline{GS_{ik}}  +  \underline{\varepsilon_{ijl}} }
$$
	
where ${y_{ijk}}$ is the response variable (e.g., grain yield) observed in the *j*th block of the *i*th genotype in the *k*th year (*i* = 1, 2, ..., *g*;  *j* = 1, 2, ..., *b*; *k* = 1, 2, ..., *y*); $\mu$ is the grand mean; ${G_i}$ is the effect of the *i*th genotype; $\underline{S}_l$ is the effect of the *k*th year; $\beta_{jk}$ is the effect of the *j*th replication (i.e., blocks) with the *k*th year; $\underline{GS_{ik}}$ is the interaction effect of the *k*th year nested within the *i*th genotype; and $\mathop \varepsilon \nolimits_{ijk}$ is the random error, in witch with $S_{k}$~N(0,$\sigma_{Y}^{2}$), $GS_{ik}$~N(0,$\sigma_{GS}^{2}$), and $\varepsilon_{ijk}$~N(0,$\sigma_{\varepsilon}^{2}$), all independent, where $\sigma_{Y}^{2}$ is the genotype (name) variance,$\sigma_{GS}^{2}$is the interaction genotype x year variance, and $\sigma_{\varepsilon}^{2}$ is the mean error variance across experiments. \n

The BLUEs will be obtained by location and rep (`rep_loc`) using a loop with [@asreml] and storage it into the `stgI_list` list. The output here will be a table with `name`, `yield_LSM`, `se` columns. 

```{r asreml blues 2, message=FALSE, warning=FALSE}
## Analysis per site
Envs <- levels(data_beans$loc)

stgI_list <- matrix(data=list(), nrow=length(Envs), ncol=1,
                    dimnames=list(Envs, c("lsmeans")))

############################
##### Stage I LSMEANS #####

for (i in Envs){
  
  Edat <- droplevels(subset(data_beans, loc==i))
  
  print(i)
  
  mod.1 <- asreml(fixed       = yield_kg_ha_adj_all ~ name:rep + name,
                  random      = ~ year + name:year ,
                  data        = Edat,
                  predict     = predict.asreml(classify = "name:rep",vcov=TRUE, aliased = T),
                  trace       = F,
                  maxit       = 500)
  
  
  print(summary.asreml(mod.1)$varcomp)
  wald(mod.1)
  
  blue.1<- data.table((mod.1$predictions$pvals[1:4])) 
  names(blue.1) <- c("name", "rep", "yield_LSM", "se")

  stgI_list[[i, "lsmeans" ]] <- blue.1 # put all the results of Stage 1 in the list
  
  rm(Edat,mod.1, blue.1)
  
  
 
}
```


### Preparing dataset of Stage I for Stage II 

Merging the original data to have all the factors in the final table with: `name`, `loc`, `expt`, `rep`, `loc`

```{r Preparing dataset to Stage II b}
##### Unlist the results of Stage I and format as data.table #####
lsm_stageI <- data.table(ldply(stgI_list[, "lsmeans"], data.frame, .id="loc"))
lsm_stageI <- lsm_stageI[order(lsm_stageI$loc,lsm_stageI$name),]

lsm_stageI$units <- seq.int(nrow(lsm_stageI))
#str(lsm_stageI)

data_beans_col <- data_beans[,c("name", "loc",  "expt","rep")]

data_beans_col <- data_beans_col[order(data_beans_col$loc,data_beans_col$name),]

lsm_stage.I <- merge(data_beans_col, lsm_stageI,
                     by=c("name", "rep", "loc"))

lsm_stage.I <- droplevels(lsm_stage.I[!duplicated(lsm_stage.I$units),])
str(lsm_stage.I)

#write.csv(lsm_stage.I,"lsm_stage.I.csv",row.names=T,quote=F)
```


### The BLUP model for MET trials

The following linear mixed model with interaction effect will be used in the 2-Stage in order to investigate the multi-environment trials (MET) as follow by [@metan] R package:

$$
{\sf\underline{Y_{ijl}} = \mu  + \underline{G_i}  + E_l + \beta_{jl} + \underline{GE_{il}}  +  \underline{\varepsilon_{ijl}} }
$$
	
where ${y_{ijl}}$ is the response variable (e.g., grain yield) observed in the *j*th block of the *i*th genotype in the *l*th location (*i* = 1, 2, ..., *g*;  *j* = 1, 2, ..., *b*; *l* = 1, 2, ..., *e*); $\mu$ is the grand mean; $\underline{G_i}$ is the effect of the *i*th genotype; $E_l$ is the effect of the *l*th location (env); $\beta_{jl}$ is the effect of the *j*th rep with the *l*th location; $\underline{GE_{il}}$ is the interaction effect of the *i*th genotype nested within the *l*th location; and $\mathop \varepsilon \nolimits_{ijl}$ is the random error, in witch with $G_{i}$~N(0,$\sigma_{G}^{2}$), $GE_{il}$~N(0,$\sigma_{GE}^{2}$), and $\varepsilon_{ijl}$~N(0,$\sigma_{\varepsilon}^{2}$), all independent, where $G_{G}^{2}$ is the genotype (name) variance,$GS_{GE}^{2}$ is the interaction genotype x environment variance, and $\sigma_{\varepsilon}^{2}$ is the mean error variance across experiments. \n

### `mod.met.5`
```{r mod met 2}
mod.met.5 <- asreml(fixed       = yield_LSM ~  loc + loc:rep,
                     random      = ~  name + name:loc,
                     data        = lsm_stage.I,
                     predict     = predict.asreml(classify = "name"),
                     trace       = F,
                     maxit       = 500)


print(wald(mod.met.5))
print(summary.asreml(mod.met.5)$varcomp)
print(summary.asreml(mod.met.5)$bic)
blup.met.5<- data.table((mod.met.5$predictions$pvals[1:3]))
names(blup.met.5) <- c("name", "yield_LSM_MET", "se")

```

### `mod.met.metan.b` Metan MET analysis
```{r mod metan 2a}
 mixed_mod.b <- 
   gamem_met(lsm_stage.I,
             env = loc,
             gen = name,
             rep = rep,
             resp = yield_LSM,
             random = "gen", #Default
             verbose = TRUE) #Default
 
 blup.metan.b<- mixed_mod.b$yield_LSM$BLUPgen
 blup.metan.int.b<- mixed_mod.b$yield_LSM$BLUPint
 blup.metan.means.b<- means_by(blup.metan.int.b,GEN,ENV)


```


## Plot comparison between two correction methods for BLUES names per Block
```{r}
data_merge_blups <- merge(blup.met.4,blup.met.5, by  = "name" )
corr.blup <- data_merge_blups  %$%
  cor.test(yield_LSM_MET.x, yield_LSM_MET.y) %>%
  tidy %>%
  mutate_if(is.numeric, round, 4)

text <- paste0('r P:BLUPs = ', corr.blup$estimate)

#annotate('text', x = 400, y = mean(pheno.add$Blue)+400,  label=text)) 

#cor.test(blup.gen$yield_LSM_MET,blup.met.4$yield_LSM_MET)
plot(blup.met.4$yield_LSM_MET,blup.met.5$yield_LSM_MET, ylab = "Blup Yield - mod.met.4", xlab = "Blup Yield - mod.met.5")
abline(0,1, col = "gray", lty = 1)
abline(lm(blup.met.4$yield_LSM_MET~ blup.met.5$yield_LSM_MET), col = "blue", lty = 2)
temp <- legend("bottomright", legend = c(" ", " "),
               text.width = strwidth("1,000,000"),
               lty = 1:2, xjust = 1, yjust = 1,
               title = "Line Types")
text(temp$rect$left + temp$rect$w, temp$text$y,
     c("1:1 line", "Fit line"), pos = 2)
text(x=2850, y=3500, labels=text)
```


# Getting started - Mixed model analysis using the [@metan] R Package
# All Market Class Beans

## `mod.met.metan.b` Metan MET analysis
```{r mod metan 2}
 mixed_mod<- 
   gamem_met(lsm_stage.I,
             env = loc,
             gen = name,
             rep = rep,
             resp = yield_LSM,
             random = "gen", #Default
             verbose = TRUE) #Default
 
 blup.metan.b<- mixed_mod.b$yield_LSM$BLUPgen
 blup.metan.int.b<- mixed_mod.b$yield_LSM$BLUPint
 blup.metan.means.b<- means_by(blup.metan.int.b,GEN,ENV)


```
### Diagnostic plot for residuals
The S3 generic function `plot()` is used to generate diagnostic plots of residuals of the model. 

```{r  echo = TRUE, fig.width=7, fig.height=7, fig.align="center"}
plot(mixed_mod)
```


The normality of the random effects of genotype and interaction effects may be also obtained by using `type = "re"`.
```{r  echo = TRUE, fig.width=10, fig.height=3.33, fig.align="center"}
plot(mixed_mod, type = "re")
```


### Printing the model outputs

#### Likelihood Ratio Tests

The output `LRT` contains the Likelihood Ratio Tests for genotype and genotype-vs-environment random effects. We can get these values with `get_model_data()`

```{r  warning=F, message=F}
data <- get_model_data(mixed_mod, "lrt")
print_table(data)
```


#### Variance components and genetic parameters

In the output `ESTIMATES`, beyond the variance components for the declared random effects, some important parameters are also shown. **Heribatility** is the broad-sense heritability, $\mathop h\nolimits_g^2$, estimated by
$$
\mathop h\nolimits_g^2  = \frac{\mathop {\hat\sigma} \nolimits_g^2} {\mathop {\hat\sigma} \nolimits_g^2  + \mathop {\hat\sigma} \nolimits_i^2  + \mathop {\hat\sigma} \nolimits_e^2 }
$$

where $\mathop {\hat\sigma} \nolimits_g^2$ is the genotypic variance; $\mathop {\hat\sigma} \nolimits_i^2$ is the genotype-by-environment interaction variance; and $\mathop {\hat\sigma} \nolimits_e^2$ is the residual variance. 

**GEIr2** is the coefficient of determination of the interaction effects, $\mathop r\nolimits_i^2$, estimated by 

$$
\mathop r\nolimits_i^2  = \frac{\mathop {\hat\sigma} \nolimits_i^2}
{\mathop {\hat\sigma} \nolimits_g^2  + \mathop {\hat\sigma} \nolimits_i^2  + \mathop {\hat\sigma} \nolimits_e^2 }
$$
**Heribatility of means** is the heribability on the mean basis, $\mathop h\nolimits_{gm}^2$, estimated by 

$$
\mathop h\nolimits_{gm}^2  = \frac{\mathop {\hat\sigma} \nolimits_g^2}{[\mathop {\hat\sigma} \nolimits_g^2  + \mathop {\hat\sigma} \nolimits_i^2 /e + \mathop {\hat\sigma} \nolimits_e^2 /\left( {eb} \right)]}
$$

where *e* and *b* are the number of environments and blocks, respectively; **Accuracy** is the accuracy of selection, *Ac*, estimated by
$$
Ac = \sqrt{\mathop h\nolimits_{gm}^2}
$$

**rge** is the genotype-environment correlation,  $\mathop r\nolimits_{ge}$, estimated by

$$
\mathop r\nolimits_{ge} = \frac{\mathop {\hat\sigma} \nolimits_g^2}{\mathop {\hat\sigma} \nolimits_g^2  + \mathop {\hat\sigma} \nolimits_i^2}
$$

**CVg** and **CVr** are the the genotypic coefficient of variation and the residual coefficient of variation estimated, respectively, by 
$$
CVg  = \left( {\sqrt {\mathop {\hat \sigma }\nolimits_g^2 } /\mu } \right) \times 100
$$
and 
$$
CVr = \left( {\sqrt {\mathop {\hat \sigma }\nolimits_e^2 } /\mu } \right) \times 100
$$
where $\mu$ is the grand mean.

**CV ratio** is the ratio between genotypic and residual coefficient of variation.


```{r  }
data <- get_model_data(mixed_mod)
print_table(data)
```


#### BLUP for genotypes


```{r  }
print_table(mixed_mod$yield_LSM $BLUPgen)
```

The function `get_model_data()` may be used to easily get the data from a model fitted with the function `gamem_met()`, especially when more than one variables are used. The following code return the predicted mean of each genotype for five variables of the data `data_ge2`.

```{r warning=FALSE }
get_model_data(mixed_mod, what = "blupg")
```



##### Plotting the BLUP for genotypes

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
library(ggplot2)
a <- plot_blup(mixed_mod)
b <- plot_blup(mixed_mod, 
               col.shape  =  c("gray20", "gray80"),
               plot_theme = theme_metan(grid = "y")) +
  coord_flip()
arrange_ggplot(a, b, tag_levels = "a")
```


This output shows the predicted means for genotypes. **BLUPg** is the genotypic effect $(\hat{g}_{i})$, which considering balanced data and genotype as random effect is estimated by

$$
\hat{g}_{i} = h_g^2(\bar{y}_{i.}-\bar{y}_{..})
$$

where $h_g^2$ is the shrinkage effect for genotype. **Predicted** is the predicted mean estimated by
$$
\hat{g}_{i}+\mu
$$

where $\mu$ is the grand mean. **LL** and **UL** are the lower and upper limits, respectively, estimated by 
$$
(\hat{g}_{i}+\mu)\pm{CI}
$$
with
$$
CI = t\times\sqrt{((1-Ac)\times{\mathop \sigma \nolimits_g^2)}}
$$

where $t$ is the Student's *t* value for a two-tailed *t* test at a given probability error; $Ac$ is the accuracy of selection and $\mathop \sigma \nolimits_g^2$ is the genotypic variance.

#### BLUP for genotypes X environment combination

```{r  }
print_table(mixed_mod$yield_LSM$BLUPint)
```

This output shows the predicted means for each genotype and environment combination. **BLUPg** is the genotypic effect described above. **BLUPge** is the genotypic effect of the *i*th genotype in the *j*th environment $(\hat{g}_{ij})$, which considering balanced data and genotype as random effect is estimated by
$$\hat{g}_{ij} = h_g^2(\bar{y}_{i.}-\bar{y}_{..})+h_{ge}^2(y_{ij}-\bar{y}_{i.}-\bar{y}_{.j}+\bar{y}_{..})$$
where $h_{ge}^2$ is the shrinkage effect for the genotype-by-environment interaction; **BLUPg+ge** is $BLUP_g+BLUP_{ge}$; **Predicted** is the predicted mean ($\hat{y}_{ij}$) estimated by
$$
\hat{y}_{ij} = \bar{y}_{.j}+BLUP_{g+ge}
$$


### Some useful information


The following pieces of information are provided in `Details` output.  **Nenv**, the number of environments in the analysis; **Ngen** the number of genotypes in the analysis; **mresp** The value attributed to the highest value of the response variable after rescaling it; **wresp** The weight of the response variable for estimating the WAASBY index. **Mean** the grand mean; **SE** the standard error of the mean; **SD** the standard deviation. **CV** the coefficient of variation of the phenotypic means, estimating WAASB, **Min** the minimum value observed (returning the genotype and environment), **Max** the maximum value observed (returning the genotype and environment); **MinENV** the environment with the lower mean, **MaxENV** the environment with the larger mean observed, **MinGEN** the genotype with the lower mean, **MaxGEN** the genotype with the larger. 

```{r  }
data <- get_model_data(mixed_mod, "details")
print_table(data)
```

## The WAASB object

The function `waasb()` function computes the Weighted Average of the Absolute Scores considering all possible IPCA from the Singular Value Decomposition of the BLUPs for genotype-vs-environment interaction effects obtained by an Linear Mixed-effect Model [@Olivoto2019], as follows:

$$
        WAASB_i  = 
        \sum_{k = 1}^{p} |IPCA_{ik} \times EP_k|/ \sum_{k = 1}^{p}EP_k
$$

where $WAASB_i$ is the weighted average of absolute scores of the *i*th genotype; $IPCA_{ik}$ is the scores of the *i*th genotype in the *k*th IPCA; and $EP_k$ is the explained variance of the *k*th PCA for $k = 1,2,..,p$, $p = min(g-1; e-1)$.


```{r  }
waasb_model <- 
  waasb(lsm_stage.I,
        env = loc,
        gen = name,
        rep = rep,
        resp = yield_LSM,
        random = "gen", #Default
        verbose = TRUE) #Default
data <- waasb_model$yield_LSM$model
print_table(data)
```

The output generated by the `waasb()` function is very similar to those generated by the `waas()` function. The main difference here, is that the singular value decomposition is based on the BLUP for GEI effects matrix.


### Eigenvalues of the BLUP_GEI matrix

```{r  }
data <- waasb_model$yield_LSM$PCA
print_table(data)
```


```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot_eigen(waasb_model, size.lab = 14, size.tex.lab = 14)
```

The above output shows the eigenvalues and the proportion of variance explained by each principal component axis of the BLUP interaction effects matrix.

### Phenotypic means

```{r  }
data <- waasb_model$yield_LSM$MeansGxE
print_table(data)
```

In this output, *Y* is the phenotypic mean for each genotype and environment combination ($y_{ij}$), estimated by $y_{ij} = \sum_k{y_{ij}}/B$ with $k = 1,2,...B$.


### Biplots

Provided that an object of class `waasb` is available in the global environment, the graphics may be obtained using the function `plot_scores()`. To do that, we will revisit the previusly fitted model `WAASB` . Please, refer to `?plot_scores` for more details. Four types of graphics can be generated: 1 = $PC1 \times PC2$;  2 = $GY \times PC1$; 3 = $GY \times WAASB$; and 4 = a graphic with nominal yield as a function of the environment PCA1 scores.

#### biplot type 1: GY x PC1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
c <- plot_scores(waasb_model, type = 1)
d <- plot_scores(waasb_model,
                 type = 1,
                 col.gen = "black",
                 col.env = "red",
                 col.segm.env = "red",
                 axis.expand = 1.5)
arrange_ggplot(c, d, tag_levels = list(c("c", "d")))
```


#### biplot type 2: PC1 x PC2

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
e <- plot_scores(waasb_model, type = 2)
f <- plot_scores(waasb_model,
                 type = 2,
                 polygon = TRUE,
                 col.segm.env = "transparent",
                 plot_theme = theme_metan_minimal())
arrange_ggplot(e, f, tag_levels = list(c("e", "f")))
```

#### biplot type 3: GY x WAASB

The quadrants proposed by @Olivoto2019 in the following biplot represent four classifications regarding the joint interpretation of mean performance and stability. The genotypes or environments included in quadrant I can be considered unstable genotypes or environments with high discrimination ability, and with productivity below the grand mean. In quadrant II are included unstable genotypes, although with productivity above the grand mean. The environments included in this quadrant deserve special attention since, in addition to providing high magnitudes of the response variable, they present a good discrimination ability. Genotypes within quadrant III have low productivity, but can be considered stable due to the lower values of WAASB. The lower this value, the more stable the genotype can be considered. The environments included in this quadrant can be considered as poorly productive and with low discrimination ability. The genotypes within the quadrant IV are highly productive and broadly adapted due to the high magnitude of the response variable and high stability performance (lower values of WAASB).    

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
g <- plot_scores(waasb_model, type = 3)
h <- plot_scores(waasb_model, type = 3,
                 x.lab = "My customized x label",
                 size.shape.gen = 3,
                 size.tex.gen = 2,
                 #x.lim = c(1.2, 4.7),
                 #x.breaks = seq(1.5, 4.5, by = 0.5),
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(g, h, tag_levels = list(c("g", "h")))
```


#### biplot type 4 : nominal yield and environment IPCA1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
i <- plot_scores(waasb_model, type = 4)
j <- plot_scores(waasb_model,
                 type = 4,
                 size.tex.gen = 1.5,
                 color = FALSE,
                 col.alpha.gen = 0,
                 col.alpha.env = 0,
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(i, j, tag_levels = list(c("i", "j")))
```


## Simultaneous selection for mean performance and stability

The **waasby** index is used for genotype ranking considering both the stability (**waasb**) and mean performance (**y**) based on the following model [@Olivoto2019].

$$
waasby_i = \frac{{\left( {r {Y_i} \times {\theta _Y}} \right) + \left( {r {W_i} \times {\theta _W}} \right)}}{{{\theta _Y} + {\theta _W}}}
$$

where $waasby_i$ is the superiority index for the *i*-th genotype; $rY_i$ and $rW_i$ are the rescaled values (0-100) for the response variable (y) and the stability (WAAS or WAASB), respectively;  $\theta _Y$ and $\theta_W$ are the weights for mean performance and stability, respectively.

This index was also already computed and stored into AMMI_model>GY>model. An intuitively plot may be obtained by running

```{r  echo = TRUE, fig.height = 4, fig.width = 10, fig.align = "center", message = F, warning = F}
i <- plot_waasby(waasb_model)
j <- plot_waasby(waasb_model, col.shape = c("gray20", "gray80"))
arrange_ggplot(i, j, tag_levels = list(c("e", "f")))
```

In the following example, we will apply the function `wsmp()` to the previously fitted model **waasb_model** aiming at planning different scenarios of **waasby** estimation by changing the weights assigned to the stability and the mean performance. The number of scenarios is defined by the arguments `increment`. By default, twenty-one different scenarios are computed. In this case, the the superiority index **waasby** is computed considering the following weights: stability (waasb or waas) = 100; mean performance = 0. In other words, only stability is considered for genotype ranking. In the next iteration, the weights becomes 95/5 (since increment = 5). In the third scenario, the weights become 90/10, and so on up to these weights become 0/100. In the last iteration, the genotype ranking for WAASY or WAASBY matches perfectly with the ranks of the response variable.

```{r  echo = TRUE}
scenarios <- wsmp(waasb_model)
```


### Printing the model outputs


```{r  }
print_table(scenarios$yield_LSM$hetcomb)
```

In addition, the genotype ranking depending on the number of multiplicative terms used to estimate the WAAS index is also computed.

```{r  }
print_table(scenarios$yield_LSM$hetdata)
```



### Plotting the heat map graphics

The first type of heatmap shows the genotype ranking depending on the number of principal component axes used for estimating the WAASB index. An euclidean distance-based dendrogram is used for grouping the genotypes based on their ranks. The second type of heatmap shows the genotype ranking depending on the WAASB/GY ratio. The ranks obtained with a ratio of 100/0 considers exclusively the stability for genotype ranking. On the other hand, a ratio of 0/100 considers exclusively the productivity for genotype ranking. Four clusters are estimated (1) unproductive and unstable genotypes; (2) productive, but unstable genotypes; (3) stable, but unproductive genotypes; and (4), productive and stable genotypes [@Olivoto2019].



#### Ranks of genotypes depending on the number of PCA used to estimate the WAASB
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 1)
```

#### Ranks of genotypes depending on the WAASB/GY ratio
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 2)
```


## Others BLUP-based stability indexes

@ColombariFilho2013 have shown the use of three BLUP-based indexes for selecting genotypes with performance and stability. The first is the harmonic mean of genotypic values -or BLUPS- (HMGV) a stability index that considers the genotype with the highest harmonic mean across environments as the most stable, as follows:

$$
HMG{V_i} = \frac{E}{{\sum\limits_{j = 1}^E {\frac{1}{{BLUP{_{ij}}}}}}}
$$

The second is the relative performance of genotypic values (RPGV), an adaptability index estimated as follows:

$$
RPGV_i = \frac{1}{e}{\sum\limits_{j = 1}^e {BLUP_{ij}} /\mathop \mu \nolimits_j }
$$

The third and last is the harmonic mean of relative performance of genotypic values (HMRPGV), a simultaneous selection index for stability, adaptability and mean performance, estimated as follows:

$$
HMRPG{V_i} = \frac{E}{{\sum\limits_{j = 1}^E {\frac{1}{{BLUP{_{ij}}/{\mu _j}}}} }}
$$


```{r  }
Res_ind <- 
lsm_stage.I %>%
gamem_met(loc, name, rep, yield_LSM, verbose = FALSE) %>% 
blup_indexes()
print_table(Res_ind$yield_LSM)
as_tibble(Res_ind$yield_LSM)
```

# By Market Class
```{r Preparing dataset to Stage II by mkt}
##### Unlist the results of Stage I and format as data.table #####
lsm_stageI <- data.table(ldply(stgI_list[, "lsmeans"], data.frame, .id="loc"))
lsm_stageI <- lsm_stageI[order(lsm_stageI$loc,lsm_stageI$name),]

lsm_stageI$units <- seq.int(nrow(lsm_stageI))
#str(lsm_stageI)

data_beans_col <- data_beans[,c("name", "loc",  "expt","rep")]

data_beans_col <- data_beans_col[order(data_beans_col$loc,data_beans_col$name),]

lsm_stage.I <- merge(data_beans_col, lsm_stageI,
                     by=c("name", "rep", "loc"))

lsm_stage.I <- droplevels(lsm_stage.I[!duplicated(lsm_stage.I$units),])
str(lsm_stage.I)

#write.csv(lsm_stage.I,"lsm_stage.I.csv",row.names=T,quote=F)
```


Getting the files for the individually market classes analysis
```{r}
lsm_stage.I_BB <- droplevels(lsm_stage.I[which(lsm_stage.I$expt=="BB")])
lsm_stage.I_NB <- droplevels(lsm_stage.I[which(lsm_stage.I$expt=="NB")])
lsm_stage.I_SR <- droplevels(lsm_stage.I[which(lsm_stage.I$expt=="SR")])
```

# Black Beans

## `mod.met.metan.bb` Metan MET analysis
```{r mod metan 2 bb}
 mixed_mod_bb<- 
   gamem_met(lsm_stage.I_BB,
             env = loc,
             gen = name,
             rep = rep,
             resp = yield_LSM,
             random = "gen", #Default
             verbose = TRUE) #Default
 
 blup.metan.bb<- mixed_mod.b$yield_LSM$BLUPgen
 blup.metan.int.bb<- mixed_mod.b$yield_LSM$BLUPint
 blup.metan.means.bb<- means_by(blup.metan.int.bb,GEN,ENV)


```
### Diagnostic plot for residuals
The S3 generic function `plot()` is used to generate diagnostic plots of residuals of the model. 

```{r  echo = TRUE, fig.width=7, fig.height=7, fig.align="center"}
plot(mixed_mod_bb)
```


The normality of the random effects of genotype and interaction effects may be also obtained by using `type = "re"`.
```{r  echo = TRUE, fig.width=10, fig.height=3.33, fig.align="center"}
plot(mixed_mod_bb, type = "re")
```


### Printing the model outputs

#### Likelihood Ratio Tests

The output `LRT` contains the Likelihood Ratio Tests for genotype and genotype-vs-environment random effects. We can get these values with `get_model_data()`

```{r  warning=F, message=F}
data <- get_model_data(mixed_mod_bb, "lrt")
print_table(data)
```


#### Variance components and genetic parameters

```{r  }
data <- get_model_data(mixed_mod_bb)
print_table(data)
```


#### BLUP for genotypes


```{r  }
print_table(mixed_mod_bb$yield_LSM $BLUPgen)
```

The following code return the predicted mean of each genotype for five variables of the data `data_ge2`.

```{r warning=FALSE }
get_model_data(mixed_mod_bb, what = "blupg")
```



##### Plotting the BLUP for genotypes

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
library(ggplot2)
a <- plot_blup(mixed_mod_bb)
b <- plot_blup(mixed_mod_bb, 
               col.shape  =  c("gray20", "gray80"),
               plot_theme = theme_metan(grid = "y")) +
  coord_flip()
arrange_ggplot(a, b, tag_levels = "a")
```

#### BLUP for genotypes X environment combination

```{r  }
print_table(mixed_mod_bb$yield_LSM$BLUPint)
```

### Some useful information

```{r  }
data <- get_model_data(mixed_mod_bb, "details")
print_table(data)
```

## The WAASB object

```{r  }
waasb_model_bb <- 
  waasb(lsm_stage.I_BB,
        env = loc,
        gen = name,
        rep = rep,
        resp = yield_LSM,
        random = "gen", #Default
        verbose = TRUE) #Default
data <- waasb_model_bb$yield_LSM$model
print_table(data)
```

### Eigenvalues of the BLUP_GEI matrix

```{r  }
data <- waasb_model_bb$yield_LSM$PCA
print_table(data)
```


```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot_eigen(waasb_model_bb, size.lab = 14, size.tex.lab = 14)
```

The above output shows the eigenvalues and the proportion of variance explained by each principal component axis of the BLUP interaction effects matrix.

### Phenotypic means

```{r  }
data <- waasb_model_bb$yield_LSM$MeansGxE
print_table(data)
```

### Biplots

#### biplot type 1: GY x PC1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
c <- plot_scores(waasb_model_bb, type = 1)
d <- plot_scores(waasb_model_bb,
                 type = 1,
                 col.gen = "black",
                 col.env = "red",
                 col.segm.env = "red",
                 axis.expand = 1.5)
arrange_ggplot(c, d, tag_levels = list(c("c", "d")))
```


#### biplot type 2: PC1 x PC2

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
e <- plot_scores(waasb_model_bb, type = 2)
f <- plot_scores(waasb_model_bb,
                 type = 2,
                 polygon = TRUE,
                 col.segm.env = "transparent",
                 plot_theme = theme_metan_minimal())
arrange_ggplot(e, f, tag_levels = list(c("e", "f")))
```

#### biplot type 3: GY x WAASB

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
g <- plot_scores(waasb_model_bb, type = 3)
h <- plot_scores(waasb_model_bb, type = 3,
                 x.lab = "My customized x label",
                 size.shape.gen = 3,
                 size.tex.gen = 2,
                 #x.lim = c(1.2, 4.7),
                 #x.breaks = seq(1.5, 4.5, by = 0.5),
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(g, h, tag_levels = list(c("g", "h")))
```


#### biplot type 4 : nominal yield and environment IPCA1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
i <- plot_scores(waasb_model_bb, type = 4)
j <- plot_scores(waasb_model_bb,
                 type = 4,
                 size.tex.gen = 1.5,
                 color = FALSE,
                 col.alpha.gen = 0,
                 col.alpha.env = 0,
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(i, j, tag_levels = list(c("i", "j")))
```


## Simultaneous selection for mean performance and stability

This index was also already computed and stored into AMMI_model>GY>model. An intuitively plot may be obtained by running

```{r  echo = TRUE, fig.height = 4, fig.width = 10, fig.align = "center", message = F, warning = F}
i <- plot_waasby(waasb_model_bb)
j <- plot_waasby(waasb_model_bb, col.shape = c("gray20", "gray80"))
arrange_ggplot(i, j, tag_levels = list(c("e", "f")))
```


```{r  echo = TRUE}
scenarios <- wsmp(waasb_model_bb)
```


### Printing the model outputs


```{r  }
print_table(scenarios$yield_LSM$hetcomb)
```

In addition, the genotype ranking depending on the number of multiplicative terms used to estimate the WAAS index is also computed.

```{r  }
print_table(scenarios$yield_LSM$hetdata)
```



### Plotting the heat map graphics

#### Ranks of genotypes depending on the number of PCA used to estimate the WAASB
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 1)
```

#### Ranks of genotypes depending on the WAASB/GY ratio
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 2)
```


## Others BLUP-based stability indexes

```{r  }
Res_ind <- 
lsm_stage.I_BB %>%
gamem_met(loc, name, rep, yield_LSM, verbose = FALSE) %>% 
blup_indexes()
print_table(Res_ind$yield_LSM)
as_tibble(Res_ind$yield_LSM)
```


# Navy beans

## `mod.met.metan.bb` Metan MET analysis
```{r mod metan 2 nb}
 mixed_mod_nb<- 
   gamem_met(lsm_stage.I_NB,
             env = loc,
             gen = name,
             rep = rep,
             resp = yield_LSM,
             random = "gen", #Default
             verbose = TRUE) #Default
 
 blup.metan.nb<- mixed_mod.b$yield_LSM$BLUPgen
 blup.metan.int.nb<- mixed_mod.b$yield_LSM$BLUPint
 blup.metan.means.nb<- means_by(blup.metan.int.nb,GEN,ENV)


```
### Diagnostic plot for residuals
The S3 generic function `plot()` is used to generate diagnostic plots of residuals of the model. 

```{r  echo = TRUE, fig.width=7, fig.height=7, fig.align="center"}
plot(mixed_mod_nb)
```


The normality of the random effects of genotype and interaction effects may be also obtained by using `type = "re"`.
```{r  echo = TRUE, fig.width=10, fig.height=3.33, fig.align="center"}
plot(mixed_mod_nb, type = "re")
```


### Printing the model outputs

#### Likelihood Ratio Tests

The output `LRT` contains the Likelihood Ratio Tests for genotype and genotype-vs-environment random effects. We can get these values with `get_model_data()`

```{r  warning=F, message=F}
data <- get_model_data(mixed_mod_nb, "lrt")
print_table(data)
```


#### Variance components and genetic parameters

```{r  }
data <- get_model_data(mixed_mod_nb)
print_table(data)
```


#### BLUP for genotypes


```{r  }
print_table(mixed_mod_nb$yield_LSM $BLUPgen)
```

The following code return the predicted mean of each genotype for five variables of the data `data_ge2`.

```{r warning=FALSE }
get_model_data(mixed_mod_nb, what = "blupg")
```



##### Plotting the BLUP for genotypes

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
library(ggplot2)
a <- plot_blup(mixed_mod_nb)
b <- plot_blup(mixed_mod_nb, 
               col.shape  =  c("gray20", "gray80"),
               plot_theme = theme_metan(grid = "y")) +
  coord_flip()
arrange_ggplot(a, b, tag_levels = "a")
```

#### BLUP for genotypes X environment combination

```{r  }
print_table(mixed_mod_nb$yield_LSM$BLUPint)
```

### Some useful information

```{r  }
data <- get_model_data(mixed_mod_nb, "details")
print_table(data)
```

## The WAASB object

```{r  }
waasb_model_nb <- 
  waasb(lsm_stage.I_NB,
        env = loc,
        gen = name,
        rep = rep,
        resp = yield_LSM,
        random = "gen", #Default
        verbose = TRUE) #Default
data <- waasb_model_nb$yield_LSM$model
print_table(data)
```

### Eigenvalues of the BLUP_GEI matrix

```{r  }
data <- waasb_model_nb$yield_LSM$PCA
print_table(data)
```


```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot_eigen(waasb_model_nb, size.lab = 14, size.tex.lab = 14)
```

The above output shows the eigenvalues and the proportion of variance explained by each principal component axis of the BLUP interaction effects matrix.

### Phenotypic means

```{r  }
data <- waasb_model_nb$yield_LSM$MeansGxE
print_table(data)
```

### Biplots

#### biplot type 1: GY x PC1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
c <- plot_scores(waasb_model_nb, type = 1)
d <- plot_scores(waasb_model_nb,
                 type = 1,
                 col.gen = "black",
                 col.env = "red",
                 col.segm.env = "red",
                 axis.expand = 1.5)
arrange_ggplot(c, d, tag_levels = list(c("c", "d")))
```


#### biplot type 2: PC1 x PC2

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
e <- plot_scores(waasb_model_nb, type = 2)
f <- plot_scores(waasb_model_nb,
                 type = 2,
                 polygon = TRUE,
                 col.segm.env = "transparent",
                 plot_theme = theme_metan_minimal())
arrange_ggplot(e, f, tag_levels = list(c("e", "f")))
```

#### biplot type 3: GY x WAASB

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
g <- plot_scores(waasb_model_nb, type = 3)
h <- plot_scores(waasb_model_nb, type = 3,
                 x.lab = "My customized x label",
                 size.shape.gen = 3,
                 size.tex.gen = 2,
                 #x.lim = c(1.2, 4.7),
                 #x.breaks = seq(1.5, 4.5, by = 0.5),
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(g, h, tag_levels = list(c("g", "h")))
```


#### biplot type 4 : nominal yield and environment IPCA1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
i <- plot_scores(waasb_model_nb, type = 4)
j <- plot_scores(waasb_model_nb,
                 type = 4,
                 size.tex.gen = 1.5,
                 color = FALSE,
                 col.alpha.gen = 0,
                 col.alpha.env = 0,
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(i, j, tag_levels = list(c("i", "j")))
```


## Simultaneous selection for mean performance and stability

This index was also already computed and stored into AMMI_model>GY>model. An intuitively plot may be obtained by running

```{r  echo = TRUE, fig.height = 4, fig.width = 10, fig.align = "center", message = F, warning = F}
i <- plot_waasby(waasb_model_nb)
j <- plot_waasby(waasb_model_nb, col.shape = c("gray20", "gray80"))
arrange_ggplot(i, j, tag_levels = list(c("e", "f")))
```


```{r  echo = TRUE}
scenarios <- wsmp(waasb_model_nb)
```


### Printing the model outputs


```{r  }
print_table(scenarios$yield_LSM$hetcomb)
```

In addition, the genotype ranking depending on the number of multiplicative terms used to estimate the WAAS index is also computed.

```{r  }
print_table(scenarios$yield_LSM$hetdata)
```



### Plotting the heat map graphics

#### Ranks of genotypes depending on the number of PCA used to estimate the WAASB
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 1)
```

#### Ranks of genotypes depending on the WAASB/GY ratio
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 2)
```


## Others BLUP-based stability indexes

```{r  }
Res_ind <- 
lsm_stage.I_NB %>%
gamem_met(loc, name, rep, yield_LSM, verbose = FALSE) %>% 
blup_indexes()
print_table(Res_ind$yield_LSM)
as_tibble(Res_ind$yield_LSM)
```



# Small Red beans

## `mod.met.metan.bb` Metan MET analysis
```{r mod metan 2 sr}
 mixed_mod_sr<- 
   gamem_met(lsm_stage.I_SR,
             env = loc,
             gen = name,
             rep = rep,
             resp = yield_LSM,
             random = "gen", #Default
             verbose = TRUE) #Default
 
 blup.metan.sr<- mixed_mod.b$yield_LSM$BLUPgen
 blup.metan.int.bb<- mixed_mod.b$yield_LSM$BLUPint
 blup.metan.means.bb<- means_by(blup.metan.int.bb,GEN,ENV)


```
### Diagnostic plot for residuals
The S3 generic function `plot()` is used to generate diagnostic plots of residuals of the model. 

```{r  echo = TRUE, fig.width=7, fig.height=7, fig.align="center"}
plot(mixed_mod_sr)
```


The normality of the random effects of genotype and interaction effects may be also obtained by using `type = "re"`.
```{r  echo = TRUE, fig.width=10, fig.height=3.33, fig.align="center"}
plot(mixed_mod_sr, type = "re")
```


### Printing the model outputs

#### Likelihood Ratio Tests

The output `LRT` contains the Likelihood Ratio Tests for genotype and genotype-vs-environment random effects. We can get these values with `get_model_data()`

```{r  warning=F, message=F}
data <- get_model_data(mixed_mod_sr, "lrt")
print_table(data)
```


#### Variance components and genetic parameters

```{r  }
data <- get_model_data(mixed_mod_sr)
print_table(data)
```


#### BLUP for genotypes


```{r  }
print_table(mixed_mod_sr$yield_LSM $BLUPgen)
```

The following code return the predicted mean of each genotype for five variables of the data `data_ge2`.

```{r warning=FALSE }
get_model_data(mixed_mod_sr, what = "blupg")
```



##### Plotting the BLUP for genotypes

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
library(ggplot2)
a <- plot_blup(mixed_mod_sr)
b <- plot_blup(mixed_mod_sr, 
               col.shape  =  c("gray20", "gray80"),
               plot_theme = theme_metan(grid = "y")) +
  coord_flip()
arrange_ggplot(a, b, tag_levels = "a")
```

#### BLUP for genotypes X environment combination

```{r  }
print_table(mixed_mod_sr$yield_LSM$BLUPint)
```

### Some useful information

```{r  }
data <- get_model_data(mixed_mod_sr, "details")
print_table(data)
```

## The WAASB object

```{r  }
waasb_model_sr <- 
  waasb(lsm_stage.I_SR,
        env = loc,
        gen = name,
        rep = rep,
        resp = yield_LSM,
        random = "gen", #Default
        verbose = TRUE) #Default
data <- waasb_model_sr$yield_LSM$model
print_table(data)
```

### Eigenvalues of the BLUP_GEI matrix

```{r  }
data <- waasb_model_sr$yield_LSM$PCA
print_table(data)
```


```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot_eigen(waasb_model_sr, size.lab = 14, size.tex.lab = 14)
```

The above output shows the eigenvalues and the proportion of variance explained by each principal component axis of the BLUP interaction effects matrix.

### Phenotypic means

```{r  }
data <- waasb_model_sr$yield_LSM$MeansGxE
print_table(data)
```

### Biplots

#### biplot type 1: GY x PC1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
c <- plot_scores(waasb_model_sr, type = 1)
d <- plot_scores(waasb_model_sr,
                 type = 1,
                 col.gen = "black",
                 col.env = "red",
                 col.segm.env = "red",
                 axis.expand = 1.5)
arrange_ggplot(c, d, tag_levels = list(c("c", "d")))
```


#### biplot type 2: PC1 x PC2

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message = F, warning = F}
e <- plot_scores(waasb_model_sr, type = 2)
f <- plot_scores(waasb_model_sr,
                 type = 2,
                 polygon = TRUE,
                 col.segm.env = "transparent",
                 plot_theme = theme_metan_minimal())
arrange_ggplot(e, f, tag_levels = list(c("e", "f")))
```

#### biplot type 3: GY x WAASB

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
g <- plot_scores(waasb_model_sr, type = 3)
h <- plot_scores(waasb_model_sr, type = 3,
                 x.lab = "My customized x label",
                 size.shape.gen = 3,
                 size.tex.gen = 2,
                 #x.lim = c(1.2, 4.7),
                 #x.breaks = seq(1.5, 4.5, by = 0.5),
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(g, h, tag_levels = list(c("g", "h")))
```


#### biplot type 4 : nominal yield and environment IPCA1

```{r  echo = TRUE, fig.height = 5, fig.width = 10, fig.align = "center", message=F, warning=F}
i <- plot_scores(waasb_model_sr, type = 4)
j <- plot_scores(waasb_model_sr,
                 type = 4,
                 size.tex.gen = 1.5,
                 color = FALSE,
                 col.alpha.gen = 0,
                 col.alpha.env = 0,
                 plot_theme = theme_metan(color.background = "white"))
arrange_ggplot(i, j, tag_levels = list(c("i", "j")))
```


## Simultaneous selection for mean performance and stability

This index was also already computed and stored into AMMI_model>GY>model. An intuitively plot may be obtained by running

```{r  echo = TRUE, fig.height = 4, fig.width = 10, fig.align = "center", message = F, warning = F}
i <- plot_waasby(waasb_model_sr)
j <- plot_waasby(waasb_model_sr, col.shape = c("gray20", "gray80"))
arrange_ggplot(i, j, tag_levels = list(c("e", "f")))
```


```{r  echo = TRUE}
scenarios <- wsmp(waasb_model_sr)
```


### Printing the model outputs


```{r  }
print_table(scenarios$yield_LSM$hetcomb)
```

In addition, the genotype ranking depending on the number of multiplicative terms used to estimate the WAAS index is also computed.

```{r  }
print_table(scenarios$yield_LSM$hetdata)
```



### Plotting the heat map graphics

#### Ranks of genotypes depending on the number of PCA used to estimate the WAASB
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 1)
```

#### Ranks of genotypes depending on the WAASB/GY ratio
```{r  echo = TRUE, fig.height = 5, fig.width = 5.5, fig.align = "center", message = F, warning = F}
plot(scenarios, type = 2)
```


## Others BLUP-based stability indexes

```{r  }
Res_ind <- 
lsm_stage.I_SR %>%
gamem_met(loc, name, rep, yield_LSM, verbose = FALSE) %>% 
blup_indexes()
print_table(Res_ind$yield_LSM)
as_tibble(Res_ind$yield_LSM)
```









## References































